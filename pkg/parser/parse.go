package parser

import (
	"fmt"

	"golang.org/x/text/unicode/norm"

	"github.com/demizer/go-rst/pkg/log"
	"github.com/demizer/go-rst/pkg/testutil"

	klog "github.com/go-kit/kit/log"

	doc "github.com/demizer/go-rst/pkg/document"
	tok "github.com/demizer/go-rst/pkg/token"
)

const (
	// Default indent width
	indentWidth = 4
)

// Parser contains the parser Parser. The Nodes field contains the parsed nodes of the input input data.
type Parser struct {
	Name     string        // The name of the current parser input
	Nodes    *doc.NodeList // The root node list
	Messages doc.NodeList  // Messages generated by the parser

	nodeTarget *doc.NodeTarget // Used to append nodes to a target NodeList
	text       string          // The input text
	lex        *tok.Lexer      // The place where tokens come from
	indents    *indentQueue    // Indent level tracking

	bqLevel *doc.BlockQuoteNode // FIXME: will be replaced with blockquoteLevels

	sectionLevels *sectionLevels     // Encountered section levels
	sections      []*doc.SectionNode // Pointers to encountered sections

	openList doc.Node // Open Bullet List, Enum List, or Definition List

	tokenBuffer // Buffered tokens from the scanner to allow going forward and back in the stream

	log.Logger
}

// New returns a fresh parser Parser.
func New(name, text string, logr klog.Logger) *Parser {
	nl := make(doc.NodeList, 0)
	t := &Parser{
		Name:          name,
		Nodes:         &nl,
		text:          text,
		sectionLevels: newSectionLevels(testutil.StdLogger),
		indents:       new(indentQueue),
		nodeTarget:    doc.NewNodeTarget(&nl, logr),
		Logger:        log.NewLogger("parser", true, testutil.LogExcludes, logr),
		tokenBuffer:   newTokenBuffer(),
	}
	t.Msgr("Parser.Nodes pointer", "nodeListPointer", fmt.Sprintf("%p", nl))
	return t
}

// Parse is the entry point for the reStructuredText parser. Errors generated by the parser are returned as a NodeList.
func Parse(name, text string, logr klog.Logger) (p *Parser, errors doc.NodeList) {
	p = New(name, text, logr)
	if !norm.NFC.IsNormalString(text) {
		text = norm.NFC.String(text)
	}
	p.Parse(text)
	errors = p.Messages
	return
}

// startParse initializes the parser, using the lexer.
func (p *Parser) startParse(lex *tok.Lexer) {
	p.lex = lex
}

// Parse activates the parser using text as input data. A parse Parser is returned on success or failure. Users of the
// Parse package should use the Top level Parse function.
func (p *Parser) Parse(text string) (*Parser, error) {
	l, err := tok.Lex(p.Name, []byte(text), p.StdLogger())
	if err != nil {
		err = fmt.Errorf("parsing error: %s", err)
	}
	p.startParse(l)
	p.text = text
	p.parse()
	return p, err
}

// parse is where items are retrieved from the parser and dispatched according to the itemElement type.
func (p *Parser) parse() {
	for {
		var n doc.Node

		token := p.next(1)
		if token == nil || token.Type == tok.EOF {
			break
		}

		p.Msgr("Parser got token", "token", token)

		switch token.Type {
		case tok.Text:
			p.paragraph(token)
		case tok.InlineEmphasisOpen:
			p.inlineEmphasis(token)
		case tok.InlineStrongOpen:
			p.inlineStrong(token)
		case tok.InlineLiteralOpen:
			p.inlineLiteral(token)
		case tok.InlineInterpretedTextOpen:
			p.inlineInterpretedText(token)
		case tok.InlineInterpretedTextRoleOpen:
			p.inlineInterpretedTextRole(token)
		case tok.Transition:
			// FIXME: Workaround until transitions are supported
			p.nodeTarget.Append(doc.NewTransition(token))
		case tok.CommentMark:
			p.comment(token)
		case tok.SectionAdornment:
			p.section(token)
		case tok.EnumListArabic:
			n = p.enumList(token)
			// FIXME: This is only until enumerated list are properly implemented.
			if n == nil {
				continue
			}
			p.nodeTarget.Append(n)
		case tok.Space:
			//
			//  FIXME: Blockquote parsing is NOT fully implemented.
			//
			if p.peekBack(1).Type == tok.BlankLine && p.bqLevel == nil {
				// Ignore if next item is a blockquote from the lexer
				if pn := p.peek(1); pn != nil && pn.Type == tok.BlockQuote {
					p.Msg("Next item is blockquote; not creating empty blockquote")
					continue
				}
				p.Msg("Creating empty blockquote!")
				p.emptyblockquote(token)
			} else if p.peekBack(1).Type == tok.BlankLine {
				p.nodeTarget.SetParent(p.bqLevel)
			}
		case tok.BlankLine, tok.Title, tok.Escape:
			// itemTitle is consumed when evaluating SectionAdornment
			continue
		case tok.BlockQuote:
			p.blockquote(token)
		case tok.DefinitionTerm:
			p.definitionTerm(token)
		case tok.Bullet:
			p.bulletList(token)
		default:
			p.Msg(fmt.Sprintf("Token type: %q is not yet supported in the parser", token.Type.String()))
		}

	}
}

func (p *Parser) subParseBodyElements(token *tok.Item) doc.Node {
	p.Msgr("Have token", "tokenType", token.Type, "tokenText", fmt.Sprintf("%q", token.Text))
	var n doc.Node
	switch token.Type {
	case tok.Text:
		n = p.paragraph(token)
	case tok.InlineEmphasisOpen:
		p.inlineEmphasis(token)
	case tok.InlineStrongOpen:
		p.inlineStrong(token)
	case tok.InlineLiteralOpen:
		p.inlineLiteral(token)
	case tok.InlineInterpretedTextOpen:
		p.inlineInterpretedText(token)
	case tok.InlineInterpretedTextRoleOpen:
		p.inlineInterpretedTextRole(token)
	case tok.CommentMark:
		p.comment(token)
	case tok.EnumListArabic:
		p.enumList(token)
	case tok.Space:
	case tok.BlankLine, tok.Escape:
	case tok.BlockQuote:
		p.blockquote(token)
	default:
		p.Msg(fmt.Sprintf("Token type: %q is not yet supported in the parser", token.Type.String()))
	}
	return n
}

func (p *Parser) subParseInlineMarkup(token *tok.Item) doc.Node {
	p.Msgr("Have token", "tokenType", token.Type, "tokenText", fmt.Sprintf("%q", token.Text))
	var n doc.Node
	switch token.Type {
	case tok.InlineEmphasisOpen:
		p.inlineEmphasis(token)
	case tok.InlineStrongOpen:
		p.inlineStrong(token)
	case tok.InlineLiteralOpen:
		p.inlineLiteral(token)
	case tok.InlineInterpretedTextOpen:
		p.inlineInterpretedText(token)
	case tok.InlineInterpretedTextRoleOpen:
		p.inlineInterpretedTextRole(token)
	default:
		p.Msg(fmt.Sprintf("Token type: %q is not inline markup", token.Type.String()))
	}
	return n
}
