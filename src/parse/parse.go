// go-rst - A reStructuredText parser for Go
// 2014,2015 (c) The go-rst Authors
// MIT Licensed. See LICENSE for details.

// Package parse is a reStructuredText parser implemented in Go!
//
// This package is only meant for lexing and parsing reStructuredText. See the
// top level package documentation for details on using the go-rst package
// package API.
package parse

import (
	"github.com/davecgh/go-spew/spew"
	"github.com/demizer/go-logs/src/logs"
	"golang.org/x/text/unicode/norm"
)

// Used for debugging only
var spd = spew.ConfigState{Indent: "\t"} //, DisableMethods: true}

// systemMessageLevel implements four levels for messages and is used in
// conjunction with the parserMessage type.
type systemMessageLevel int

const (
	levelInfo systemMessageLevel = iota
	levelWarning
	levelError
	levelSevere
)

var systemMessageLevels = [...]string{
	"INFO",
	"WARNING",
	"ERROR",
	"SEVERE",
}

// String implments Stringer and return a string of the systemMessageLevel.
func (s systemMessageLevel) String() string {
	return systemMessageLevels[s]
}

// FromString returns the systemMessageLevel converted from the string name.
func systemMessageLevelFromString(name string) systemMessageLevel {
	for num, sLvl := range systemMessageLevels {
		if name == sLvl {
			return systemMessageLevel(num)
		}
	}
	return -1
}

// parserMessage implements messages generated by the parser. Parser messages
// are leveled using systemMessageLevels.
type parserMessage int

const (
	parserMessageNil parserMessage = iota
	infoOverlineTooShortForTitle
	infoUnexpectedTitleOverlineOrTransition
	infoUnderlineTooShortForTitle
	warningShortOverline
	warningShortUnderline
	warningExplicitMarkupWithUnIndent
	errorInvalidSectionOrTransitionMarker
	severeUnexpectedSectionTitle
	severeUnexpectedSectionTitleOrTransition
	severeIncompleteSectionTitle
	severeMissingMatchingUnderlineForOverline
	severeOverlineUnderlineMismatch
	severeTitleLevelInconsistent
)

var parserErrors = [...]string{
	"parserMessageNil",
	"infoOverlineTooShortForTitle",
	"infoUnexpectedTitleOverlineOrTransition",
	"infoUnderlineTooShortForTitle",
	"warningShortOverline",
	"warningShortUnderline",
	"warningExplicitMarkupWithUnIndent",
	"errorInvalidSectionOrTransitionMarker",
	"severeUnexpectedSectionTitle",
	"severeUnexpectedSectionTitleOrTransition",
	"severeIncompleteSectionTitle",
	"severeMissingMatchingUnderlineForOverline",
	"severeOverlineUnderlineMismatch",
	"severeTitleLevelInconsistent",
}

// String implements Stringer and returns the parserMessage as a string. The
// returned string is the parserMessage name, not the message itself.
func (p parserMessage) String() string {
	return parserErrors[p]
}

// Message returns the message of the parserMessage as a string.
func (p parserMessage) Message() (s string) {
	switch p {
	case infoOverlineTooShortForTitle:
		s = "Possible incomplete section title.\n" +
			"Treating the overline as ordinary text because " +
			"it's so short."
	case infoUnexpectedTitleOverlineOrTransition:
		s = "Unexpected possible title overline or transition.\n" +
			"Treating it as ordinary text because it's so short."
	case infoUnderlineTooShortForTitle:
		s = "Possible title underline, too short for the title.\n" +
			"Treating it as ordinary text because it's so short."
	case warningShortOverline:
		s = "Title overline too short."
	case warningShortUnderline:
		s = "Title underline too short."
	case warningExplicitMarkupWithUnIndent:
		s = "Explicit markup ends without a blank line; " +
			"unexpected unindent."
	case errorInvalidSectionOrTransitionMarker:
		s = "Invalid section title or transition marker."
	case severeUnexpectedSectionTitle:
		s = "Unexpected section title."
	case severeUnexpectedSectionTitleOrTransition:
		s = "Unexpected section title or transition."
	case severeIncompleteSectionTitle:
		s = "Incomplete section title."
	case severeMissingMatchingUnderlineForOverline:
		s = "Missing matching underline for section title overline."
	case severeOverlineUnderlineMismatch:
		s = "Title overline & underline mismatch."
	case severeTitleLevelInconsistent:
		s = "Title level inconsistent."
	}
	return
}

// Level returns the parserMessage level.
func (p parserMessage) Level() (s systemMessageLevel) {
	lvl := int(p)
	switch {
	case lvl > 0 && lvl <= 3:
		s = levelInfo
	case lvl <= 6:
		s = levelWarning
	case lvl == 7:
		s = levelError
	case lvl >= 8:
		s = levelSevere
	}
	return
}

// sectionLevel is a single section level. sections containes a list of
// pointers to SectionNode that are dertermined to be a section of the level
// indicated by level. rChar is the rune character that denotes the section
// level.
type sectionLevel struct {
	rChar    rune
	level    int
	overLine bool           // True if the section level has an overline.
	sections []*SectionNode // Sections matching level.
}

// sectionLevels contains the encountered section levels in order by level.
// levels[0] is section level 1 and levels[1] is section level 2.
// lastSectionNode is a pointer to the lastSectionNode added to levels.
type sectionLevels struct {
	lastSectionNode *SectionNode
	levels          []*sectionLevel
}

// FindByRune loops through the sectionLevels to find a section using a Rune as
// the key. If the section is found, a pointer to the SectionNode is returned.
func (s *sectionLevels) FindByRune(rChar rune) *sectionLevel {
	for _, sec := range s.levels {
		if sec.rChar == rChar {
			return sec
		}
	}
	return nil
}

// Add determines if the underline rune in the sec argument matches any
// existing sectionLevel in sectionLevels. Add also checks the section level
// ordering is correct and returns a severeTitleLevelInconsistent parserMessage
// if inconsistencies are found.
func (s *sectionLevels) Add(sec *SectionNode) (err parserMessage) {
	level := 1
	secLvl := s.FindByRune(sec.UnderLine.Rune)

	// Local function for creating a sectionLevel
	var newSectionLevel = func() {
		var oLine bool
		if sec.OverLine != nil {
			oLine = true
		}
		logs.Debugln("Creating new sectionLevel:", level)
		secLvl = &sectionLevel{
			rChar: sec.UnderLine.Rune,
			level: level, overLine: oLine,
		}
		s.levels = append(s.levels, secLvl)
		// secLvl.sections = append(secLvl.sections, sec)
	}

	if secLvl == nil {
		if s.lastSectionNode != nil {
			// Check if the provisional level of sec is already in
			// sectionLevels; if it is and the adornment characters
			// don't match, then we have an inconsistent level
			// error.
			level = s.lastSectionNode.Level + 1
			nextLevel := s.SectionLevelByLevel(level)
			if nextLevel != nil &&
				nextLevel.rChar != sec.UnderLine.Rune {
				return severeTitleLevelInconsistent
			}
		} else {
			level = len(s.levels) + 1
		}
		newSectionLevel()
	} else {
		if secLvl.overLine && sec.OverLine == nil ||
			!secLvl.overLine && sec.OverLine != nil {
			// If sec has an OverLine, but the matching
			// sectionLevel with the same Rune as sec does not have
			// an OverLine, then they are not in the same
			// sectionLevel, and visa versa.
			level = len(s.levels) + 1
			newSectionLevel()
		} else {
			logs.Debugln("Using sectionLevel:", secLvl.level)
			level = secLvl.level
		}
	}

	secLvl.sections = append(secLvl.sections, sec)
	sec.Level = level
	s.lastSectionNode = sec
	return
}

// SectionLevelByLevel returns a pointer to a sectionLevel of level level. Nil
// is returned if l is greater than the number of section levels encountered.
func (s *sectionLevels) SectionLevelByLevel(level int) *sectionLevel {
	if level > len(s.levels) {
		return nil
	}
	return (s.levels)[level-1]
}

// LastSectionByLevel returns a pointer to the last section encountered by
// level.
func (s *sectionLevels) LastSectionByLevel(level int) (sec *SectionNode) {
exit:
	for i := len(s.levels) - 1; i >= 0; i-- {
		if (s.levels)[i].level != level {
			continue
		}
		for j := len((s.levels)[i].sections) - 1; j >= 0; j-- {
			sec = (s.levels)[i].sections[j]
			if sec.Level == level {
				logs.Debugln("Found sectionLevel:", sec.Level)
				break exit
			}
		}
	}
	return
}

// Parse is the entry point for the reStructuredText parser. Errors generated
// by the parser are returned as a NodeList.
func Parse(name, text string) (t *Tree, errors NodeList) {
	t = New(name, text)
	if !norm.NFC.IsNormalString(text) {
		text = norm.NFC.String(text)
	}
	t.Parse(text, t)
	errors = t.Messages
	return
}

// New returns a fresh parser tree.
func New(name, text string) *Tree {
	return &Tree{
		Name:          name,
		text:          text,
		sectionLevels: new(sectionLevels),
		indentWidth:   indentWidth,
	}
}

const (
	// The middle of the Tree.token buffer so that there are three possible
	// "backup" token positions and three forward "peek" positions.
	zed = 4

	// Default indent width
	indentWidth = 4
)

// Tree contains the parser tree. The Nodes field contains the parsed nodes of
// the input input data.
type Tree struct {
	Name               string    // The name of the current parser input
	Nodes              NodeList  // The root node list
	Messages           NodeList  // Messages generated by the parser
	nodeTarget         *NodeList // Used to append nodes to a target NodeList
	text               string    // The input text
	lex                *lexer
	token              [9]*item
	sectionLevels      *sectionLevels // Encountered section levels
	sections           []*SectionNode // Pointers to encountered sections
	id                 int            // Consecutive id of the node in the tree
	indentWidth        int
	indentLevel        int
	openDefinitionList *NodeList
	openBulletList     *NodeList
}

// startParse initializes the parser, using the lexer.
func (t *Tree) startParse(lex *lexer) {
	t.lex = lex
}

// Parse activates the parser using text as input data. A parse tree is
// returned on success or failure. Users of the Parse package should use the
// Top level Parse function.
func (t *Tree) Parse(text string, treeSet *Tree) (tree *Tree) {
	t.startParse(lex(t.Name, []byte(text)))
	t.text = text
	t.parse(treeSet)
	return t
}

// parse is where items are retrieved from the parser and dispatched according
// to the itemElement type.
func (t *Tree) parse(tree *Tree) {

	t.nodeTarget = &t.Nodes

	for t.peek(1).Type != itemEOF {
		var n interface{}

		token := t.next(1)
		logs.Infof("Parser got token: %#+v\n", token)

		// FIXME: Hackish. Need to find a better way...
		if t.indentLevel > 0 && token.StartPosition == 1 &&
			token.Type != itemSpace && token.Type != itemBlankLine &&
			token.Type != itemDefinitionTerm {
			t.indentLevel = 0
			t.openDefinitionList = nil
			t.nodeTarget = &t.Nodes
		}

		switch token.Type {
		case itemParagraph:
			n = t.paragraph(token)
		case itemTransition:
			n = newTransition(token, &t.id)
		case itemCommentMark:
			n = t.comment(token)
		case itemSectionAdornment:
			n = t.section(token)
		case itemEnumListArabic:
			n = t.enumList(token)
			// FIXME: This is only until enumerated list are
			// properly implemented.
			if n == nil {
				continue
			}
		case itemSpace:
			if t.peekBack(1).Type == itemBlankLine && t.indentLevel == 0 {
				n = t.blockquote(token)
			}
			if n == nil {
				// The calculated indent level was the same as
				// the current indent level. Future items will
				// be added to the NodeList using the
				// nodeTarget below.
				continue
			}
		case itemTitle, itemBlankLine:
			// itemTitle is consumed when evaluating
			// itemSectionAdornment
			continue
		case itemBlockQuote:
			n = t.blockquote(token)
		case itemDefinitionTerm:
			if t.openDefinitionList == nil && t.indentLevel == 0 {
				n = t.definitionList(token)
				t.openDefinitionList = &n.(*DefinitionListNode).NodeList
				break
			}
			n = t.definitionListItem(token)
			t.nodeTarget = t.openDefinitionList
			t.indentLevel++
		case itemBullet:
			// FIXME: This will get fixed when I am ready for full
			// bullet list support.
			var nn Node
			if t.openBulletList == nil && t.indentLevel == 0 {
				nn = t.bulletList(token)
				t.nodeTarget.append(nn.(Node))
				t.openBulletList = &nn.(*BulletListNode).NodeList
			}
			n = t.bulletListItem(token)
			t.nodeTarget = t.openBulletList
			t.indentLevel++
		}

		t.nodeTarget.append(n.(Node))
		// Set the loop to append items to the NodeList of the new
		// section
		switch n.(Node).NodeType() {
		case NodeSection:
			t.nodeTarget = &n.(*SectionNode).NodeList
		case NodeBlockQuote:
			t.nodeTarget = &n.(*BlockQuoteNode).NodeList
		case NodeDefinitionListItem:
			t.nodeTarget = &n.(*DefinitionListItemNode).Definition.NodeList
		case NodeBulletListItem:
			t.nodeTarget = &n.(*BulletListItemNode).NodeList
		}
	}
}

// backup shifts the token buffer right one position.
func (t *Tree) backup() {
	t.token[0] = nil
	for x := len(t.token) - 1; x > 0; x-- {
		t.token[x] = t.token[x-1]
		t.token[x-1] = nil
	}
}

// peekBack uses the token buffer to "look back" a number of positions (pos).
// Looking back more positions than the Tree.token buffer allows (3) will
// generate a panic.
func (t *Tree) peekBack(pos int) *item {
	return t.token[zed-pos]
}

func (t *Tree) peekBackTo(item itemElement) (tok *item) {
	for i := zed - 1; i >= 0; i-- {
		if t.token[i] != nil && t.token[i].Type == item {
			tok = t.token[i]
			break
		}
	}
	return
}

// peek looks ahead in the token stream a number of positions (pos) and gets
// the next token from the lexer. A pointer to the token is kept in the
// Tree.token buffer. If a token pointer already exists in the buffer, that
// token is used instead and no tokens are received the the lexer stream
// (channel).
func (t *Tree) peek(pos int) *item {
	nItem := t.token[zed]
	for i := 1; i <= pos; i++ {
		if t.token[zed+i] != nil {
			nItem = t.token[zed+i]
			logs.Debugf("Using %#+v\n", nItem)
			continue
		} else {
			if t.lex == nil {
				continue
			}
			logs.Debugln("Getting next item")
			t.token[zed+i] = t.lex.nextItem()
			nItem = t.token[zed+i]
		}
	}
	return nItem
}

// peekSkip looks ahead one position skipiing a specified itemElement. If that
// element is found, a pointer is returned, otherwise nil is returned.
func (t *Tree) peekSkip(iSkip itemElement) *item {
	var nItem *item
	count := 1
	for {
		nItem = t.peek(count)
		if nItem.Type != iSkip {
			break
		}
		count++
	}
	return nItem
}

// next is the workhorse of the parser. It is repsonsible for getting the next
// token from the lexer stream (channel). If the next token already exists in
// the token buffer, than the token buffer is shifted left and the pointer to
// the "zed" token is returned. pos specifies the number of times to call next.
func (t *Tree) next(pos int) *item {
	if pos == 0 {
		return t.token[zed]
	}
	for x := 0; x < len(t.token)-1; x++ {
		t.token[x] = t.token[x+1]
		t.token[x+1] = nil
	}
	if t.token[zed] == nil && t.lex != nil {
		t.token[zed] = t.lex.nextItem()
	}
	pos--
	if pos > 0 {
		t.next(pos)
	}
	return t.token[zed]
}

// clearTokens sets tokens from begin to end to nil.
func (t *Tree) clearTokens(begin, end int) {
	for i := begin; i <= end; i++ {
		t.token[i] = nil
	}
}

// section is responsible for parsing the title, overline, and underline tokens
// returned from the parser. If there are errors parsing these elements, than a
// systemMessage is generated and added to Tree.Nodes.
func (t *Tree) section(i *item) Node {
	var overAdorn, indent, title, underAdorn *item

	pBack := t.peekBack(1)
	pFor := t.peekSkip(itemSpace)
	tZedLen := t.token[zed].Length

	if pFor != nil && pFor.Type == itemTitle {
		// Section with overline
		pBack := t.peekBack(1)
		// Check for errors
		if tZedLen < 3 && tZedLen != pFor.Length {
			t.next(2)
			bTok := t.peekBack(1)
			if bTok != nil && bTok.Type == itemSpace {
				t.next(2)
				m := infoUnexpectedTitleOverlineOrTransition
				return t.systemMessage(m)
			}
			return t.systemMessage(infoOverlineTooShortForTitle)
		} else if pBack != nil && pBack.Type == itemSpace {
			// Indented section (error)
			// The section title has an indented overline
			m := severeUnexpectedSectionTitleOrTransition
			return t.systemMessage(m)
		}

		overAdorn = i
		t.next(1)

	loop:
		for {
			switch tTok := t.token[zed]; tTok.Type {
			case itemTitle:
				title = tTok
				t.next(1)
			case itemSpace:
				indent = tTok
				t.next(1)
			case itemSectionAdornment:
				underAdorn = tTok
				break loop
			}
		}
	} else if pBack != nil &&
		(pBack.Type == itemTitle || pBack.Type == itemSpace) {
		// Section with no overline
		// Check for errors
		if pBack.Type == itemSpace {
			pBack := t.peekBack(2)
			if pBack != nil && pBack.Type == itemTitle {
				// The section underline is indented
				m := severeUnexpectedSectionTitle
				return t.systemMessage(m)
			}
		} else if tZedLen < 3 && tZedLen != pBack.Length {
			// Short underline
			return t.systemMessage(infoUnderlineTooShortForTitle)
		}

		// Section OKAY
		title = t.peekBack(1)
		underAdorn = i

	} else if pFor != nil && pFor.Type == itemParagraph {
		// If a section contains an itemParagraph, it is because the
		// underline is missing, therefore we generate an error based
		// on what follows the itemParagraph.
		t.next(2) // Move the token buffer past the error tokens
		if tZedLen < 3 && tZedLen != pFor.Length {
			t.backup()
			return t.systemMessage(infoOverlineTooShortForTitle)
		} else if p := t.peek(1); p != nil && p.Type == itemBlankLine {
			m := severeMissingMatchingUnderlineForOverline
			return t.systemMessage(m)
		}
		return t.systemMessage(severeIncompleteSectionTitle)
	} else if pFor != nil && pFor.Type == itemSectionAdornment {
		// Missing section title
		t.next(1) // Move the token buffer past the error token
		return t.systemMessage(errorInvalidSectionOrTransitionMarker)
	} else if pFor != nil && pFor.Type == itemEOF {
		// Missing underline and at EOF
		return t.systemMessage(errorInvalidSectionOrTransitionMarker)
	}

	if overAdorn != nil &&
		overAdorn.Text != underAdorn.Text {
		return t.systemMessage(severeOverlineUnderlineMismatch)
	}

	// Determine the level of the section and where to append it to in
	// t.Nodes
	undoID := t.id
	sec := newSection(title, overAdorn, underAdorn, indent, &t.id)
	logs.Debugf("Adding  %#U to sectionLevels\n", sec.UnderLine.Rune)

	msg := t.sectionLevels.Add(sec)
	if msg != parserMessageNil {
		logs.Debugln("Found inconsistent section level!")
		t.id = undoID
		return t.systemMessage(severeTitleLevelInconsistent)
	}

	sec.Level = t.sectionLevels.lastSectionNode.Level
	if sec.Level == 1 {
		logs.Debugln("Setting nodeTarget to Tree.Nodes!")
		t.nodeTarget = &t.Nodes
	} else {
		lSec := t.sectionLevels.lastSectionNode
		if sec.Level > 1 {
			lSec = t.sectionLevels.LastSectionByLevel(sec.Level - 1)
		}
		t.nodeTarget = &lSec.NodeList
		logs.Debugln("Setting nodeTarget to section ID",
			lSec.ID.String())
	}

	// The following checks have to be made after the SectionNode has been
	// initialized so that any parserMessages can be appended to the
	// SectionNode.NodeList.
	oLen := title.Length
	if indent != nil {
		oLen = indent.Length + title.Length
	}

	if overAdorn != nil && oLen > overAdorn.Length {
		m := warningShortOverline
		sec.NodeList = append(sec.NodeList, t.systemMessage(m))
	} else if overAdorn == nil && title.Length != underAdorn.Length {
		m := warningShortUnderline
		sec.NodeList = append(sec.NodeList, t.systemMessage(m))
	}
	return sec
}

func (t *Tree) comment(i *item) Node {
	var n Node
	if t.peek(1).Type == itemBlankLine {
		logs.Debugln("Found empty comment block")
		return newComment(&item{
			StartPosition: i.StartPosition,
			Line:          i.Line,
		}, &t.id)
	}
	nSpace := t.peek(1)
	if nSpace != nil && nSpace.Type != itemSpace {
		// The comment element itself is valid, but we need to add it
		// to the NodeList before the systemMessage.
		logs.Debugln("Missing space after comment mark! " +
			"(warningExplicitMarkupWithUnIndent)")
		n = newComment(&item{Line: i.Line}, &t.id)
		t.nodeTarget.append(n)
		return t.systemMessage(warningExplicitMarkupWithUnIndent)
	}
	nPara := t.peek(2)
	if nPara != nil && nPara.Type == itemParagraph {
		t.next(2)
		if t.peek(1).Type == itemSpace && t.peek(2).Type == itemParagraph {
			logs.Debugln("Found NodeComment block")
			t.next(2)
			for {
				nPara.Text += "\n" + t.token[zed].Text
				if t.peek(1).Type == itemSpace &&
					t.peek(2).Type == itemParagraph {
					t.next(2)
				} else {
					break
				}
			}
			nPara.Length = len(nPara.Text)
		} else if z := t.peek(1).Type; z != itemBlankLine &&
			z != itemCommentMark && z != itemEOF {
			// A valid comment contains a blank line after the
			// comment block
			logs.Debugln("Found warningExplicitMarkupWithUnIndent")
			n = newComment(nPara, &t.id)
			t.nodeTarget.append(n)
			return t.systemMessage(warningExplicitMarkupWithUnIndent)
		} else {
			logs.Debugln("Found NodeComment")
		}
		n = newComment(nPara, &t.id)
	}
	return n
}

// systemMessage generates a Node based on the passed parserMessage. The
// generated message is returned as a SystemMessageNode.
func (t *Tree) systemMessage(err parserMessage) Node {
	var lbText string
	var lbTextLen int
	var backToken int

	s := newSystemMessage(&item{
		Type: itemSystemMessage,
		Line: t.token[zed].Line,
	},
		err, &t.id)

	msg := newParagraph(&item{
		Text:   err.Message(),
		Length: len(err.Message()),
	}, &t.id)
	s.NodeList = append(s.NodeList, msg)

	logs.Debugln("FOUND", err)
	// if t.token[zed].Line == 9 {
	// spd.Dump(t.token)
	// os.Exit(1)
	// }
	var overLine, indent, title, underLine, newLine string

	switch err {
	case infoOverlineTooShortForTitle:
		var inText string
		if t.token[zed-2] != nil {
			inText = t.token[zed-2].Text + "\n" +
				t.token[zed-1].Text + "\n" + t.token[zed].Text
			s.Line = t.token[zed-2].Line
			t.token[zed-2] = nil
		} else {
			inText = t.token[zed-1].Text + "\n" + t.token[zed].Text
			s.Line = t.token[zed-1].Line
		}
		infoTextLen := len(inText)
		// Modify the token buffer to change the current token to a
		// itemParagraph then backup the token buffer so the next loop
		// gets the new paragraph
		t.token[zed-1] = nil
		t.token[zed].Type = itemParagraph
		t.token[zed].Text = inText
		t.token[zed].Length = infoTextLen
		t.token[zed].Line = s.Line
		t.backup()
	case infoUnexpectedTitleOverlineOrTransition:
		oLin := t.peekBackTo(itemSectionAdornment)
		titl := t.peekBackTo(itemTitle)
		uLin := t.token[zed]
		inText := oLin.Text + "\n" + titl.Text + "\n" + uLin.Text
		s.Line = oLin.Line
		t.clearTokens(zed-4, zed-1)
		infoTextLen := len(inText)
		// Modify the token buffer to change the current token to a
		// itemParagraph then backup the token buffer so the next loop
		// gets the new paragraph
		t.token[zed].Type = itemParagraph
		t.token[zed].Text = inText
		t.token[zed].Length = infoTextLen
		t.token[zed].Line = s.Line
		t.token[zed].StartPosition = oLin.StartPosition
		t.backup()
	case infoUnderlineTooShortForTitle:
		inText := t.token[zed-1].Text + "\n" + t.token[zed].Text
		infoTextLen := len(inText)
		s.Line = t.token[zed-1].Line
		// Modify the token buffer to change the current token to a
		// itemParagraph then backup the token buffer so the next loop
		// gets the new paragraph
		t.token[zed-1] = nil
		t.token[zed].Type = itemParagraph
		t.token[zed].Text = inText
		t.token[zed].Length = infoTextLen
		t.token[zed].Line = s.Line
		t.backup()
	case warningShortOverline, severeOverlineUnderlineMismatch:
		backToken = zed - 2
		if t.peekBack(2).Type == itemSpace {
			backToken = zed - 3
			indent = t.token[zed-2].Text
		}
		overLine = t.token[backToken].Text
		title = t.token[zed-1].Text
		underLine = t.token[zed].Text
		newLine = "\n"
		lbText = overLine + newLine + indent + title + newLine +
			underLine
		s.Line = t.token[backToken].Line
		lbTextLen = len(lbText)
	case warningShortUnderline, severeUnexpectedSectionTitle:
		backToken = zed - 1
		if t.peekBack(1).Type == itemSpace {
			backToken = zed - 2
		}
		lbText = t.token[backToken].Text + "\n" + t.token[zed].Text
		lbTextLen = len(lbText)
		s.Line = t.token[zed-1].Line
	case warningExplicitMarkupWithUnIndent:
		s.Line = t.token[zed+1].Line
	case errorInvalidSectionOrTransitionMarker:
		lbText = t.token[zed-1].Text + "\n" + t.token[zed].Text
		s.Line = t.token[zed-1].Line
		lbTextLen = len(lbText)
	case severeIncompleteSectionTitle,
		severeMissingMatchingUnderlineForOverline:
		lbText = t.token[zed-2].Text + "\n" +
			t.token[zed-1].Text + t.token[zed].Text
		s.Line = t.token[zed-2].Line
		lbTextLen = len(lbText)
	case severeUnexpectedSectionTitleOrTransition:
		lbText = t.token[zed].Text
		lbTextLen = len(lbText)
		s.Line = t.token[zed].Line
	case severeTitleLevelInconsistent:
		if t.peekBack(2).Type == itemSectionAdornment {
			lbText = t.token[zed-2].Text + "\n" +
				t.token[zed-1].Text + "\n" + t.token[zed].Text
			lbTextLen = len(lbText)
			s.Line = t.token[zed-2].Line
		} else {
			lbText = t.token[zed-1].Text + "\n" + t.token[zed].Text
			lbTextLen = len(lbText)
			s.Line = t.token[zed-1].Line
		}
	}

	if lbTextLen > 0 {
		lb := newLiteralBlock(&item{
			Type:   itemLiteralBlock,
			Text:   lbText,
			Length: lbTextLen,
		}, &t.id)
		s.NodeList = append(s.NodeList, lb)
	}

	t.Messages.append(s)

	return s
}

var lastEnum *EnumListNode

func (t *Tree) enumList(i *item) (n Node) {
	// FIXME: This function is COMPLETELY not final. It is only setup for
	// passing section test TitleNumberedGood0100.
	var eNode *EnumListNode
	var affix *item
	if lastEnum == nil {
		t.next(1)
		affix = t.token[zed]
		t.next(1)
		eNode = newEnumListNode(i, affix, &t.id)
		t.next(1)
		eNode.NodeList.append(newParagraph(t.token[zed], &t.id))
	} else {
		t.next(3)
		lastEnum.NodeList.append(newParagraph(t.token[zed], &t.id))
		return nil
	}
	lastEnum = eNode
	return eNode
}

func (t *Tree) paragraph(i *item) Node {

	npItem := &item{
		Text:          i.Text,
		Line:          i.Line,
		StartPosition: i.StartPosition,
	}

	// Get all the paragraphs. If the paragraphs are not separted by blank
	// lines, then add a newline between the previous paragraph and the
	// current.
	for {
		nItem := t.next(1)
		if nItem.Type != itemParagraph {
			t.backup()
			break
		}
		npItem.Text += "\n" + nItem.Text
	}

	npItem.Length = len(npItem.Text)

	sec := newParagraph(npItem, &t.id)

	return sec
}

func (t *Tree) blockquote(i *item) Node {
	logs.Debugln("Got type", i.Type)
	s := i
	if i.Type != itemSpace {
		// If i is not itemSpace, it is a itemBlockQuote. In that case
		// we will get the last itemSpace token found to use for the
		// indent level calculation.
		s = t.peekBackTo(itemSpace)
	}
	level := s.Length / t.indentWidth

	logs.Debugf("t.indentLevel == level :: %d == %d\n", t.indentLevel, level)
	if t.indentLevel == level {
		i.Type = itemParagraph
		return newParagraph(i, &t.id)
	}

	if i.Type == itemSpace {
		if t.peek(1).Type != itemBlockQuote {
			t.indentLevel = level
			return newBlockQuote(
				&item{Type: itemBlockQuote, Line: i.Line},
				level, &t.id)
		}
		logs.Debugln("Next item is itemBlockQuote")
		return nil
	}

	levelChanged := false
	if t.indentLevel != level {
		logs.Debugln("Setting indentLevel to ", level)
		t.indentLevel = level
		levelChanged = true
	}

	var sec Node
	n := *i

	if levelChanged {
		// FIXME: Code a token ring insertion API
		t.token[zed+1] = &n
		t.indentLevel = level
		sec = newBlockQuote(&item{Type: itemBlockQuote, Line: i.Line,
			StartPosition: i.StartPosition, Length: i.Length}, level,
			&t.id)
	}

	return sec
}

func (t *Tree) definitionList(i *item) Node {
	sec := newDefinitionList(&item{Line: i.Line}, &t.id)
	// backup so the parser will get the same token and on the next go
	// around the token will be added to the NodeList if the definition
	// list created here.
	t.backup()
	// Tell the parser we have an open definition list. Future definition
	// terms will be appended to the definition list.
	return sec
}

func (t *Tree) definitionListItem(i *item) Node {
	// TODO: Check for proper indentation!
	def := t.peek(2)
	return newDefinitionListItem(i, def, &t.id)
}

func (t *Tree) bulletList(i *item) Node {
	return newBulletListNode(i, &t.id)
}

func (t *Tree) bulletListItem(i *item) Node {
	return newBulletListItemNode(i, &t.id)
}
